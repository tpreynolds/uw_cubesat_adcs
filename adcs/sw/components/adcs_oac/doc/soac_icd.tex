\documentclass[10pt]{article}

% Load commands & pakcages
\input{preamble.tex}
\input{my_tikz.tex}

% \addbibresource{PDG.bib}

\title{\textsc{SOAC Interface Control Document \\ {\small \textbf{S}attelite for \textbf{O}ptimal \textbf{C}ontrol and \textbf{I}maging}}}

 \author{
  Taylor P. Reynolds%
  \thanks{Ph.D. Candidate, RAIN Lab, W.E. Boeing Department of Aeronautics \& Astronautics, University of Washington: \texttt{tpr6@uw.edu} } }
 \date{\today}

\begin{document}
 
\maketitle

This document is the interface control document for the primary payload of the SOCi mission. The payload is SOCi's Optimal Attitude Controller (SOAC), and uses convex optimization techniques to compute guidance trajectories that steers the spacecraft to a desired orientation while satisfying numerous constraints of interest. Specifically, trajectories are generated that respect angular rate bounds, torque bounds, and attitude inclusion and exclusion zone constraints. 

This document provides a summary of the system, technical details on how the controller works, the interfaces to other parts of the spacecraft, and the verification and validation procedure used to ensure proper operation. I have stashed all of the data tables at the back to keep the document readable.

\section{Summary of System}\label{sec:summary}

The SOAC payload is a software component within the Guidance, Navigation, and Control (GNC) subsystem and is the primary payload of the mission. The SOAC payload will produce feedforward reaction wheel torque commands and a reference state vector in order to control the orientation of the spacecraft. All reorientations will be performed starting from the spacecraftâ€™s current attitude, and will terminate at a ground-specified attitude. The maneuver begins at a time that is pre-specified and steers the spacecraft to a desired final attitude, both of which are given as inputs; see~\sref{sec2:cmd_interface}.

A block diagram of the SOAC control system is provided in~\fref{fig:soac_loop}. It must be coupled with a feedback controller (shown as $C(s)$) to compensate for small errors that accumulate during the execution of a feedforward maneuver. Note that the ``difference'' junction used to compute the state errors is not a subtraction since quaternions are used; however the same symbol is overloaded for ease of understanding.

\begin{figure}[bth]
\centering
\input{figs/tikz_soac_loop.tex}
\caption{Abstract control loop for the SOAC payload. The controller represented by $C(s)$ is not designed as part of the payload.}
\label{fig:soac_loop}
\end{figure}

\subsection{Problem Statement}

The problem that is solved by the SOAC payload can be summarized as follows. Define the state and control vectors to be
\begin{equation}
\bm{x}(t) = \begin{bmatrix}
\q(t) \\ \hB(t) \\ \hw(t)
\end{bmatrix}_{10\times 1}, \quad \text{and} \quad \bm{\tau}(t) = \begin{bmatrix}
\tau_x(t) \\ \tau_y(t) \\ \tau_z(t)
\end{bmatrix} \in \real^3,
\label{eq:state_control}
\end{equation}
where $\tau_x,\,\tau_y,\,\tau_z$ are the components of the net torque vector about the spacecraft's body axes, $\q\in\real^4$ is the attitude quaternion, $\hB\in\real^3$ is the spacecraft bus angular momentum (in the body frame) and $\hw\in\real^3$ is the net reaction wheel angular momentum about the spacecraft body axes. 

The equations of motion are assumed to be (supressing the argument of time)
\begin{equation}
\dot{\bm{x}} = \begin{bmatrix}
\dot{\q} \\ \dhB \\ \dhw
\end{bmatrix} = \begin{bmatrix}
\tfrac{1}{2} \q \otimes \left(\inv{J} \hB \right) \\
-\bm{\tau} + \left( \hB + \hw \right)^{\times} \left( J^{-1} \hB \right) \\
\bm{\tau}
\end{bmatrix}.
\label{eq:eqms}
\end{equation}

The problem statement is given below. See the Appendix for an explanation of the constraints and how they are formulated. The cost function aims to minimize the power consumed by the reaction wheels to perform the maneuver. The $\mathcal{L}_2$ norm of the net torque signal is used to model their power consumption. The details and specific formulae used to achieve the computation of such trajectories are provided in an Appendix to this document, and will soon be replaced by a publication.

\begin{equation}\tag{Problem 1}\label{prob:prob1}
\begin{alignedat}{1}
\min_{t_f,\,\bm{\tau}(\cdot)} &\quad \int_{\ti}^{\tf} \bm{\tau}\tran\bm{\tau}(t) dt \\
\text{subject to:} &\quad \eqref{eq:eqms} \\
&\quad \| \inv{J}\hB \|_{\infty} \leq \wmax \\
&\quad \| \bm{\tau} \|_{\infty} \leq \taumax \\
&\quad \q^T \ME \q \leq 2 \\
&\quad \q^T \MI \q \leq 2 \\
&\quad \tfmin \leq \tf \leq \tfmax\\
&\quad \q(\ti) = \qic,\quad \hB(\ti)=\hBic,\quad \hw(\ti)=\hwic, \\
&\quad \q(\tf) = \q_f,\quad \hB(\tf) = 0.
\end{alignedat}
\end{equation}
Note that the fourth and fifth constraints define the attitude exclusion zone (due to the camera) and the attitude inclusion zone (due to the sun sensor) respectively. Details on how this constraint is formulated can be found in~\cite{Lee2015}. They are each a second-order cone constraint due to their quadratic nature. All other inequality constraints are linear. Hence all inequality constraints are convex, as are the boundary conditions (the final two lines of constraints) and the cost function. The nonlinear dynamics represent the sole non-convexity of the problem.

\section{System Interfaces}\label{sec:interfaces}

\subsection{System Overview}\label{sec2:sys_overview} 

\begin{figure}[tbh]
\centering
\input{figs/tikz_soac_inner.tex}
\caption{A representation of the input/output structure of the SOAC payload and its two primary functional components. The input \code{gnc\_mode} triggers the execution of the \textit{SOLVE} block which pulls in all unconnected inputs.}
\label{fig:soac_inner}
\end{figure}

A block diagram representation of the overall system is given in~\fref{fig:soac_inner}. The SOAC library takes nine inputs and provides outpus outputs; details of each are provided in Table~\ref{tab:inputs_outputs}. The main function of the library is to use inputs 2-7 to define a point-to-point attitude reorientation problem, and then to solve for a feedforward trajectory (state, control and maneuver time) that will reorient the satellite while respecting each constraint. 

The SOLVE function contains the custom-written parser and interface to the ECOS solver. When called upon, it will parse the data (inputs 2-7) into a series of convex optimization problems that approximate the non-convex optimal control problem given in~\ref{prob:prob1}. The solution that is computed then gets passed to the INTERP function so that it may be transformed to a set of reference state and control vectors with the same sampling time as the primary GNC flight software. Since the discretization scheme used in the SOLVE function will necessarily be a much coarser one, this is effectively a discrete-to-continuous transformation. It uses a fixed step-size RK4 integration scheme to do so. 

The components of the \code{soac\_telemetry} struct are given in Table~\ref{tab:soac_telemetry}. The first three are the converged solution from the SOLVE function. The first ten entries in \code{exitcode} are the ECOS solver return values for each of the (maximum) ten iterations. The $11$th is a custom signal to provide additional information about the computed solution. The possible values are given in Table~\ref{tab:exitcodes}. The \code{slv\_time\_s} is the ECOS-reported time taken to solve each iteration's convex optimization problem. This time is \textit{setup and solve} time, and is computed in the \code{matlab\_main.c} function. Finally, the \code{soac\_count} is an integer that indicates how many times (in total) the SOLVE function has been called.

\subsubsection{Constraint Boundary Values}

The constraint boundaries have the following values, each of which are configurable parameters:
\begin{enumerate}
\item an angular rate limit of $\omega_{\max} = 0.1~\unit{rad/s}$,
\item a torque limit of $\tau_{\max} = 3.2~\unit{mNm}$,
\item a final time between $t_{f,\min}=15~\unit{s}$ and $t_{f,\max}=25~\unit{s}$,
\item the inertial sun vector remains within a $\theta_{\max}=60\unit{\dg}$ degree cone (half-angle) centered around the sun sensor boresight direction,
\item the inertial sun vector remains outside of a $\theta_{\min}=60\unit{\dg}$ degree cone (half-angle) centered around the camera boresight direction. 
\end{enumerate} 

\subsubsection{SOAC Operating Modes}\label{sec3:op_modes}
There are effectively two operating modes of the SOAC payload: operational and idle. The trigger attached to the \code{gnc\_mode} shown in~\fref{fig:soac_inner} is the arbiter between the two modes. The output of the trigger goes high when the following conditions are met:
\begin{enumerate}
\item The value of \code{gnc\_mode = 33},
\item The previous value of \code{gnc\_mode != 33}.
\end{enumerate}
The SOAC payload can be commanded to its operational mode by the primary GNC mode manager by switching the value of \code{gnc\_mode} to $33$ from something else. The conditions upon which the primary GNC operating mode is set to $33$ are provided in the \todo{link main GNC ICD}. Maintaining the primary GNC mode at this value will not continuously trigger the payload due to the second clause. As a result, the primary GNC mode must be toggled back to some value that is not $33$ prior to requesting another solution. \textbf{The primary GNC flight software is assumed to be in charge of requesting a re-solve for a given maneuver.} The reason is that a re-solve commanded internally will inevitably create an algebraic loop. A brief attempt was made to design this into the library, but a decision was made to manage this within the primary GNC mode manager. 

\subsubsection{Control Torque Allocation}\label{sec3:allocation}

The equations of motion used in the SOAC system are given in the Appendix. Since we are using a four-wheel system, a note is needed on what assumptions are being made about how the torques computed by SOAC should be allocated to the wheels. The SOAC payload computes the \textbf{net} torque about the spacecraft body axes that should be applied to perform the maneuver, while accounting for the \textbf{net} momentum in the wheels using these same axes. 

Let $\bm{H}\in\real^4$ be the vector whose components are the angular momenta stored in each wheel and let $\bm{T}\in\real^4$ be the vector whose components are the torques delivered by each wheel. Assuming that the net angular momentum of the wheels, $\hw$, is related to the momentum of each wheel, $\bm{H}$, according to some map $g : \real^4 \rightarrow \real^3$, we have
\begin{equation}
\hw = g(\bm{H}).
\end{equation}
It should be clear that the net torque, $\bm{\tau}$, is related to the torque given by each wheel, $\bm{T}$, according to the same relationship. 

This section sets some ground rules for how the map $g$ is chosen, and offers a possible choice. The equations of motion~\eqref{eq:eqms} should actually read 
\begin{equation}
\dot{\bm{x}} = \begin{bmatrix}
\dot{\q} \\ \dhB \\ \dot{\bm{H}}
\end{bmatrix} = \begin{bmatrix}
\tfrac{1}{2} \q \otimes \left(\inv{J} \hB \right) \\
-g(\bm{T}) + \left( \hB + g(\bm{H}) \right)^{\times} \left( J^{-1} \hB \right) \\
\bm{T}
\end{bmatrix},
\label{eq:new_eqms}
\end{equation}
for an \textit{eleven-dimensional state} $\bm{x} = \left[ \q\tran \ \hB\tran \ \bm{H}\tran \right]\tran$. These equations of motion come from the conservation of momentum combined with the four-wheel geometry. The equations in~\eqref{eq:new_eqms} \textit{are equivalent to} those in~\eqref{eq:eqms} if and only if
\begin{enumerate}
\item There exists a map $g^{\dagger} : \real^4 \rightarrow \real^3$ such that $\bm{z} = g\big( g^{\dagger}(\bm{z})\big)$ for any $\bm{z}\in\real^3$. 
\item $\der{}{t}g(\bm{z}(t)) = g(\dot{\bm{z}}(t))$ for any $\bm{z}(t)\in\real^4$.
\end{enumerate}
Together these conditions should ensure that no matter what allocation scheme is used downstream of the SOAC payload, the intended behaviour will be recovered. 

\paragraph{An Example Allocation Method:} Suppose that the net momentum is related to the momentum in each wheel by
\begin{equation}
\hw = \begin{bmatrix}
\cos\beta & 0 & -\cos\beta & 0 \\ 0 & \cos\beta & 0 & -\cos\beta \\ \sin\beta & \sin\beta & \sin\beta & \sin\beta
\end{bmatrix} \bm{H} = A_w \bm{H}
\end{equation}
The $3\times 4$ matrix $A_w$ is singular, but following~\cite[\S 7.3.4]{Sidi1997} the pseudo-inverse can be used to write 
\begin{equation}
\bm{T} = A_w^{\dagger} \bm{\tau} \quad \text{and} \quad \bm{H} = A_w^{\dagger} \hw
\end{equation}
where $A_w^{\dagger} = A_w\tran \inv{\left(A_w A_w\tran\right)} \in \real^{4\times 3}$
is such that $A_w A_w^{\dagger} = \eye{3}$. Thus the mapping $g(T) = A_w$ satisfies the first condition required above (existence of an "inverse" like function). Next, it is clear that the second condition is satisfied because the matrix $A_w$ is constant. So this allocation scheme will ensure that SOAC produces the expected behaviour. This was verified in simulation by mapping an optimal set of controls $\bm{\tau}(t)$ to $\bm{T}(t)$ for $t\in[0,\tf]$ and then integrating the equations of motion~\eqref{eq:new_eqms} using the \code{Q\_ode\_4p} function. The resulting state vector matched exactly the output of SOAC.



% Provide a functional block diagram of the system here. What is the main function of this system, what does it do? What are the inputs/outputs? How does information/power/etc. flow from input to output? What are the operating modes of your system, and how do they relate to the operating modes described in the Concept of Operations? You can break it down as much as you need here to give sufficient detail as to how your system operates. This is your chance to go into detail about how you have organized things to solve the problem you formulated in the summary section.  You should produce a state diagram (example here) detailing in plain english how your system will operate in every possible scenario.

\subsection{Mechanical Interface}\label{sec2:mech_interface}

The SOAC payload is a software function that will be run on the main flight computer. There is no separate mechanical interface.

\subsection{Electrical Interface}\label{sec2:elec_interface}

The SOAC payload is a software function that will be run on the main flight computer. There is no separate electrical interface. \todo{it may be worth characterizing the expected increase in current draw when we are calling the solver. Is this something we can measure? Is it useful?}

\subsection{Command and Data Interface}\label{sec2:cmd_interface}

All inputs listed in~\tabref{tab:inputs_outputs} will come from the main GNC flight software. Refer to \todo{link main GNC ICD}. 

The output \ttt{soac\_solution} must be saved for future downlink to the ground station. This has been included in the COM system's measurement budget, and shall be maintained by CDH immediately once it is made available by SOAC. The two remaining outputs are to be provided as the GNC guidance solution and feed forward to the feedback controller that is used during primary GNC mode $33$. 

\subsection{Thermal Interface}\label{sec2:thermal_interface}

The SOAC payload is a software component that will be run on the main flight computer. There is no separate thermal interface. However, running the SOAC payload may cause an marked increase in the flight computer's computational load, and therefore it may produce more heat than nominal operating conditions. By calling SOAC only once (instead of repeatedly, see~\sref{sec3:op_modes}) it is hoped that SOAC will not create a large difference in thermal properties than what is expected for the main flight computer.

% \section{System Operation}\label{sec:sys_operation}

% How does your system work? From power up to performing its function, what are the steps that somebody would need to take? Write this like a recipe book for somebody new who is knowledgeable in the area but did not create the system. You need to be detailed here, remember nobody knows what you know about your system! 

\section{Verification and Validation}\label{sec:v_and_v}

This section outlines the testing campaign that SOAC will pass during design, as well as a test case that can be used to assess correct functionality during a bench test.

This section will detail your testing campaign. The test campaign must be designed to prove beyond doubt that your system meets all mission requirements and all risks are minimized. You can point to different documents where you have a more thorough explanation of the results, but you must at least

Cover what was tested, and how. What specific system responses did you test for? What were the limitations (i.e. what did you not test)? Have you tested every scenario/operating condition that we expect to see in our operations?  What were the pass/fail criteria and why?
Data that proves that the tests were passed and/or failed. 
Any other details that you think our reviewers would ask about. (Ask yourself the question: If I were reviewing this system, what are the weaknesses? How would I poke holes in the design, and how would this thing fail? What have I missed?)


\clearpage
\section*{Reference Tables}

\begin{table}[tbh]
\caption{Description of the SOAC payload's inputs and outputs}
\label{tab:inputs_outputs}
\centering
\begin{tabular}{ccccL{8cm}}
\multicolumn{5}{l}{\textbf{Inputs}}\\\hline\hline
\null & \textbf{Name} & \textbf{Size} & \textbf{Type} & \textbf{Description} \\ \hline
1 & \ttt{gnc\_mode} & \textit{scalar} & \code{int8} & The current GNC system operating mode. \\
2 & \ttt{quat\_ic}  & $4 \times 1$ & \code{double} & The current estimated attitude of the s/c. \\ 
3 & \ttt{w\_ic\_radps}  & $3 \times 1$ & \code{double} & The current estimated angular velocity of the s/c.\\
4 & \ttt{hw\_ic\_Nms} & $3 \times 1$ & \code{double} & The current momentum vector of the reaction wheels. \\
5 & \ttt{quat\_cmd} & $4 \times 1$ & \code{double} & The desired attitude at the end of the maneuver \\
6 & \ttt{w\_cmd\_radps} & $3 \times 1$ & \code{double} & The desired angular velocity at the end of the maneuver \\
7 & \ttt{sun\_inertial\_unit} & $3 \times 1$ & \code{double} & The inertial sun direction at the current time. This is assumed to be constant over the duration of the maneuver. \\
8 & \ttt{MET\_epoch} & \textit{scalar} & \code{double} & The maneuver epoch time in units of mission elapsed time (MET) provided via ground command prior to maneuver execution. \\
9 & \ttt{MET\_current} & \textit{scalar} & \code{double} & The current value of MET. \\~\\
\multicolumn{5}{l}{\textbf{Outputs}}\\\hline\hline
\null & \textbf{Name} & \textbf{Size} & \textbf{Type} & \textbf{Description} \\ \hline
1 & \ttt{soac\_telemetry} & $153\times 1$ & double & The entire output from the SOAC iterations. This should all be routed to ground for post-processing. See~Table~\ref{tab:soac_telemetry}.\\
2 & \ttt{command\_state} & $10\times 1$ & \code{double} & The interpolated state vector to be used as a reference for the feedback control system.\\
3 & \ttt{command\_torque} & $3\times 1$ & \code{double} & The interpolated control vector to be used as a feedforward actuator command.
\end{tabular}
\end{table}

\begin{table}[bht]
\caption{The components of the \code{soac\_telemetry} struct.}
\label{tab:soac_telemetry}
\centering
\begin{tabular}{ccc}
\textbf{Name} & \textbf{Size} & \textbf{Type} \\ \hline\hline
\code{opt\_state} & $100$ & \code{double} \\
\code{opt\_ctrl\_Nm} & $30$ & \code{double} \\
\code{final\_time\_s} & $1$ & \code{double} \\
\code{exitcode} & $11$ & \code{double} \\
\code{slv\_time\_s} & $10$ & \code{double} \\
\code{soac\_count} & $1$ & \code{uint32} \\
\end{tabular}
\end{table}

\begin{table}[bht]	
\caption{Possible values and meanings of \code{exitcode}.}
\label{tab:exitcodes}
\centering
\begin{tabular}{cC{11cm}}
\multicolumn{2}{l}{\textbf{From ECOS: Entries 1-10}}\\\hline\hline
\textbf{Value} & \textbf{Description} \\ \hline 
0 & Optimal solution found \\ 
1 & Certificate of primal infeasibility found \\
2 & Certificate of dual infeasibility found \\
10 & Optimal solution found subject to reduced tolerances \\
11 & Certificate of primal infeasibility found subject to reduced tolerances \\
12 & Certificate of dual infeasibility found subject to reduced tolerances \\
-1 & Maximum number of iterations reached \\
-2 & Numerical problems: unreliable search direction \\
-3 & Numerical problems: slacks or multipliers outside cone \\
-4 & Interrupted by signal or CTRL-C \\
-7 & Unknown problem in solver \\~\\
\multicolumn{2}{l}{\textbf{Custom: Entry 11}}\\\hline\hline
\textbf{Value} & \textbf{Description} \\ \hline 
0 & All iterates found optimal solution and the terminal iterate meets the convergence criteria \\
-1 & One of the iterates was not a 1 or 10 \\
3 & Maximum number of iterations reached: virtual control too large \\
4 & Maximum number of iterations reached: state change too large  
\end{tabular}
\end{table}


\clearpage
\section*{Appendix: Technical Details}

A general convex optimization problem is expressed
\begin{subequations}
\begin{align}
\min_{\bm{z}} &\quad f_0(\bm{z}) \\
\text{subject to:} &\quad h_i(\bm{z}) = 0, \quad i=1,\ldots,n_{eq} \\
&\quad f_j(\bm{z}) \leq 0, \quad j = 1,\ldots,n_{iq}
\end{align}
\end{subequations}
where $\bm{z}\in\real^{n_z}$ denotes the \textit{solution variable}, $f_0$ is the cost function, the $h_i$ are the \textit{equality constraints} and the $f_j$ are the \textit{inequality constraints}. The functions $f_j$ for $j=0,1,\ldots,n_{iq}$ must be \textit{convex functions} of the variable $\bm{z}$, while the functions $h_i$ for $i=1,\ldots,n_{eq}$ must be \textit{affine} functions of the variable $\bm{z}$.

\subsection*{Convex Cones}

Each proper cone $\coneK$ defines a \textit{generalized inequality} such that we may write $G \bm{z} \conleq h$ if and only if $h - G \bm{z} \in \coneK$. In particular we shall care about two cones, the \textit{linear cones} and the \textit{quadratic cones}. Linear cones are denoted by the set 
\begin{equation}
\lcone{n} = \{ \bm{z}\in\real^n \,|\, \bm{z} \geq 0 \},
\label{eq:lcone_set}
\end{equation}
where the inequality is understood elementwise. The other type of convex cones that we use are the second order cones, each of which are a set $\qcone{n+1}$ defined by
\begin{equation}
\qcone{n+1} = \big\{ (z_0,\bm{z}_n)\in\real\times\real^n \,|\, z_0 \geq \| \bm{z}_n \|_2 \big\}.
\label{eq:soc_set}
\end{equation}


To see how these are used to express various constraints as second order cone constraints, first note that a standard quadratic form is expressed as
\begin{equation}
\bm{x}^T A ^T A \bm{x} + b^T \bm{x} + c \leq 0
\label{eq:soc_quad}
\end{equation}
where $(A,b,c) \in \real^{n\times n} \times \real^n \times \real$ are constant constraint parameters. In standard form, this constraint is expressed by
\begin{equation}
\biggr\| \begin{bmatrix}
A \bm{x} \\ \frac{1}{\sqrt{2}}( 1 + c + b^T \bm{x} )
\end{bmatrix} \biggr\|_2 \leq \frac{1}{\sqrt{2}} ( 1 - b^T \bm{x} - c),
\label{eq:soc_std}
\end{equation} 
The proof of which follows from some straight-forward algebra. Now observe that according to the definition in~\eqref{eq:soc_set} we would like
\begin{equation*}
\begin{bmatrix}
\frac{1}{\sqrt{2}} ( 1 - b^T \bm{x} - c) \\
A \bm{x} \\
\frac{1}{\sqrt{2}} ( 1 + b^T \bm{x} + c)
\end{bmatrix} \in \qcone{n+2}
\end{equation*}
It should be clear that the first entry in the vector about is equivalent to $z_0$ in~\eqref{eq:soc_set}, and the remaining rows are equivalent to $\bm{z}_n$. Now, ECOS would like the matrix-vector pair $(G,h)$ such that $h-G\bm{x}\in\qcone{n+2}$, and so we set
\begin{equation}
h \definedas \begin{bmatrix}
\frac{1}{\sqrt{2}}( 1 - c ) \\ \zeros{n}{1} \\ \frac{1}{\sqrt{2}}(1+c)
\end{bmatrix} \quad G \definedas \begin{bmatrix}
\frac{b^T}{\sqrt{2}} \\ -A \\ -\frac{b^T}{\sqrt{2}}.
\end{bmatrix}
\end{equation}
The pair $(G,h)$ may be passed to ECOS to represent the quadratic constraint~\eqref{eq:soc_quad}.

\subsection*{Continuous Problem Formulation}

The continuous time optimal control problem to be solved is as follows. \todo{define ME and MI.}
\begin{problem}\label{prob:prob1}
Find the time $\tf^*\in\realpp$ and torque commands $\bm{\tau} : [\ti,\tf^*] \rightarrow \real^3$ such that
\begin{subequations}
\begin{align}
\min_{\tf,\bm{\tau}(\cdot)} &\quad \int_{\ti}^{\tf^*} \bm{\tau}\tran\bm{\tau} dt \label{eq:prob_cost}\\
\text{subject to} &\quad \qdot = \frac{1}{2} \q \otimes \wB \label{eq:prob_b}\\
&\quad \dhB = \bm{\tau} + (\hB+\hw)^{\times} \left( \inv{J} \hB \right)\label{eq:prob_c}\\
&\quad \dhw = -\bm{\tau} \\
&\quad \| \wB \|_{\infty} \leq \wmax \label{eq:prob_d}\\
&\quad \| \uB \|_{\infty} \leq \umax \label{eq:prob_e}\\
&\quad \q^T \ME \q < 2 \label{eq:prob_f}\\
&\quad \q^T \MI \q < 2 \label{eq:prob_g}\\
&\quad \tfmin \leq \tf \leq \tfmax \label{eq:prob_h}\\
&\quad \q(\ti) = \qic,\quad \wB(\ti)=\wic,\quad \hw(\ti)=\hwic, \\
&\quad \q(\tf) = \q_f,\,\wB(\tf) = 0.\label{eq:prob_i}
\end{align}
\end{subequations}
\end{problem} 

\subsection*{Transcription to Second-Order Cone Program}
This section details the steps necessary to obtain a convex second-order cone approximation of~\ref{prob:prob1} that is solved repeatedly, until convergence, within the SOLVE block of~\fref{fig:soac_inner}.

\paragraph{Time Normalization}
We define our \textit{state} to be $\bm{x} = \big[ \q \; \wB \big]^T \in \real^7$ and our \textit{control} to be $\bm{u} = \uB \in \real^3$. The dynamics in~\eqref{eq:prob_b} and~\eqref{eq:prob_c} can then be expressed in general using
\begin{equation}
\dot{\bm{x}}(t) = f(\bm{x},\bm{u}), \quad t \in [\ti,\tf].
\label{eq:dynamics_general}
\end{equation}
Since we are solving for the maneuvers final time, we must map the free-final time problem in Problem~\ref{prob:prob1} to a fixed-final time problem. We do so by defining a \textit{normalized time} $\tau\in[0,1]$ and changing our dynamics~\eqnref{eq:dynamics_general} to be
\begin{equation}
\der{\bm{x}}{t} = \der{\bm{x}}{\tau}\der{\tau}{t} = f(\bm{x},\bm{u}) \quad \Rightarrow \quad \der{\bm{x}}{\tau} = \der{t}{\tau} f(\bm{x},\bm{u})
\label{eq:dynamics_normalized}
\end{equation}
where $s \definedas \der{t}{\tau}$ is called the \textit{time-scaling factor}. By including $s$ as a solution variable, we can recover the final time for the maneuver using the relation $t_f = s \tau_f$. Since $\tau_f = 1$ by definition, we see that $s = t_f$. I use $s$ to keep the equations looking nicer.

\paragraph{Linearization}

\todo{Provide the Jacobians.}

\paragraph{Discretization}

Without any (active) state constraints, we know that the optimal torque solution for the time-optimal reorientation is bang-bang. As such, we should elect to parameterize our control with either piecewise constant or piecewise linear basis functions. We have chosen the latter, a first order hold (FOH), after some preliminary testing of the two methods against each other. 

% First, we split the maneuver into $N$ evenly spaced temporal intervals. Since we will ultimately linearize the kinematics and dynamics, we want to choose $N$ such that over each interval this linearization remains valid. Given $\q(\ti)$ and $\q(\tf)$, we can compute the angle error between these according to
% \begin{equation}
% \varphi_{err} = 2*\cos^{-1} \left( \big[ \q(\tf)^* \otimes \q(\ti) \big]_{\text{s}} \right),
% \label{eq:err_angle}
% \end{equation}
% where the operation $[\cdot]_{\text{s}}$ extracts the scalar part of a quaternion. 
% % Assuming that a linearization is valid over $\zeta$ degrees, the number of discretization nodes is computed as 
% % \begin{equation}
% % N = \lceil \frac{\varphi_{err}}{\zeta} \rceil.
% % \label{eq:N}
% % \end{equation}

First, we discretize time into $N$ evenly spaced intervals, where the size of each interval should be such that a linearization of our equations of motion remains roughly valid. For now we proceed with $N\in[5,10]$. 
\begin{equation}
\ti < t_1 < \ldots < t_{N-1} < \tf
\end{equation}
and represent the discretized time points using $k \definedas t_k$. Now, instead of the \textit{continuous times} $t\in(\ti,\tf]$, we have the \textit{discrete times} $k\in\{\ti,\,t_1,\,\ldots,\,t_{N-1},\,\tf\}$.

I'm leaving out a bunch of details for now, but the discretization method reformulates~\eqnref{eq:dynamics_normalized} into the form
\begin{equation}
\bm{X} = A \bm{X} + B \bm{U} + S s + \bm{R}
\label{eq:discrete_dynamics}
\end{equation}
where $\{\bm{A},\bm{B},\bm{S},\bm{R}\}$ are computed by the function \code{foh.m}. The constraints in~\eqref{eq:prob_d}-\eqref{eq:prob_g} are all ``discretized'' by simply applying them at the discrete temporal nodes only. 

\paragraph{Virtual Control}

To guide the convergence process, we introduce a new term to address the issue of \textit{artificial infeasibility}. This stems from the fact that the linearization may produce an infeasible interation if there does not exists some admissible control that satisfies~\eqref{eq:discrete_dynamics}. We augment the dynamics with a virtual control term that allows us to synthetically retain feasibility according to
\begin{equation}
\bm{X} = A \bm{X} + B \bm{U} + \bm{S} s + \bm{R} + \bm{V}
\label{eq:VC_discrete_dynamics}
\end{equation}
where $\bm{V}$ can be thought of as an unconstrained input that needn't respect the physical dynamics of the problem. We heavily penalize the use of virtual control (so that we only use it when absolutely necessary) by augmenting the cost function~\eqref{eq:prob_cost} with $\wv \| \bm{V} \|_1$.

After these modifications, we now have a convex parameter optimization problem that can be run on-board the spacecraft. 

\begin{problem}\label{prob:prob2}
Find the final time $s$ and the control $\bm{U}\in\real^{3 \times N}$ such that
\begin{subequations}\label{eq:prob2}
\begin{align}
\min_{s,\bm{U},\bm{X},\bm{V}} &\quad s + \wv \| \bm{V} \|_1 \label{eq:p2_a}\\
\text{subject to:} &\quad \bm{X} = A \bm{X} + B \bm{U} + \bm{S} s + \bm{R} + \bm{V} \label{eq:p2_b}\\
&\quad \| \Hw \bm{x}_k \|_{\infty} \leq \wmax, \quad k=0,\ldots,N \label{eq:p2_c}\\ 
&\quad \| \bm{u}_k \|_{\infty} \leq \umax, \quad k=0,\ldots,\{N \text{ or } N-1\} \label{eq:p2_d}\\
&\quad \bm{x}_k^T \Hq^T \ME \Hq \bm{x}_k < 2, \quad k=0,\ldots,N \label{eq:p2_e}\\
&\quad \bm{x}_k^T \Hq^T \MI \Hq \bm{x}_k < 2, \quad k=0,\ldots,N \label{eq:p2_f}\\
&\quad \tfmin \leq s \leq \tfmax \label{eq:p2_g}\\
&\quad \bm{x}_0 = \big[ \q_0^T \; 0^T \big]^T, \; \bm{x}_N = \big[ \q_f^T \; 0^T \big]^T \label{eq:p2_h}
\end{align}
\end{subequations}
where $\bm{X} = \big[ \bm{x}_0^T \; \bm{x}_1^T \; \ldots \; \bm{x}_{N}^T ]^T \in \real^{7 \times N}$ and similarly for $\bm{U}$. Moreover, $\Hq = \big[ \eye{4} \; \zeros{4}{3} \big]$ and $\Hw = \big[ \zeros{3}{4} \; \eye{3} \big]$.
\end{problem}

\paragraph{Scaling}
\todo{add scaling method}

\paragraph{Standard Form of Constraints}

Let us say that our combined \textit{solution vector} is 
\begin{equation*}
\bm{z} = \begin{bmatrix}
\bm{X}^T & \bm{U}^T & s & \bm{V}^T & \bm{\eta}_v^T
\end{bmatrix} \in \real^{n_z}
\end{equation*}
where $n_z = N(3N_x + N_u)+1$. We will first map the cost function to standard form for second-order cone problems. The cost function must be linear, and so we will use the epigraph form to rewrite the cost function~\eqref{eq:p2_a} as
\begin{equation}
\bm{c}^T \bm{z}, \quad \bm{c} = \big[ \zeros{1}{N n_x} \ \zeros{1}{N n_u} \ 1 \ \zeros{1}{N n_x} \ w_{\eta} \ones{1}{N n_x} \big]
\label{eq:std_cost}
\end{equation}
and add the following linear constraint to Problem~\ref{prob:prob2}
\begin{equation}
- \bm{\eta}_v \leq \bm{V} \leq \bm{\eta}_v.
\label{eq:p2_epi}
\end{equation}

We can thenwrite the equality constraints~\eqref{eq:p2_b} and~\eqref{eq:p2_h} as
\begin{equation}
\begin{bmatrix}
\big[ \eye{n_x} \ \zeros{n_x}{(N-1)n_x}] & \zeros{n_x}{N n_u} & \zeros{n_x}{1} & \zeros{n_x}{N n_x} & \zeros{n_x}{N n_x} \\
\bm{A} - \eye{N n_x} & \bm{B} & \bm{S} & \eye{N n_x} & \zeros{N n_x}{N n_x} \\
\big[ \zeros{n_x}{(N-1)n_x} \ \eye{n_x} \big] & \zeros{n_x}{N n_u} & \zeros{n_x}{1} & \zeros{n_x}{Nn_x} & \zeros{n_x}{N n_x}
\end{bmatrix} \bm{z} = \begin{bmatrix}
\bm{x}_0 \\ -\bm{R} \\ \bm{x}_f
\end{bmatrix}.
\label{eq:std_equality}
\end{equation}
The linear inequality constraints in~\eqref{eq:p2_c}, \eqref{eq:p2_d}, \eqref{eq:p2_g} and \eqref{eq:p2_epi} are expressed as
\begin{equation}
\begin{bmatrix}
H_w^T \\ - H_w^T \\ H_u^T \\ - H_u^T \\ H_s^T \\ - H_s^T \\ H_v^T - H_{\eta_v}^T \\ -H_v - H_{\eta_v}^T
\end{bmatrix} \bm{z} \leq \begin{bmatrix}
w_{\max} \ones{3N}{1} \\ w_{\max} \ones{3N}{1} \\ u_{\max} \ones{N n_u}{1} \\ u_{\max} \ones{N n_u}{1} \\ t_{f,\max} \\ -t_{f,\min} \\ \zeros{N n_x}{1} \\ \zeros{N n_x}{1}
\end{bmatrix},
\label{eq:std_ineq_lin}
\end{equation}
where,
\begin{gather*}
H_u = \begin{bmatrix}
\zeros{N n_x}{N n_u} \\ \eye{N n_u} \\ \zeros{2 N n_x + 1}{N n_u}
\end{bmatrix}, \quad H_s = \begin{bmatrix}
\zeros{N(n_x+n_u)}{1} \\ 1 \\ \zeros{2N n_x}{1}
\end{bmatrix}, \quad H_v = \begin{bmatrix}
\zeros{N (n_x+n_u) + 1}{N n_x} \\ \eye{N n_x} \\ \zeros{N n_x}{N n_x} 
\end{bmatrix}  \\
H_{\eta_v} = \begin{bmatrix}
\zeros{N(2n_x+n_u)+1}{N n_x} \\ \eye{N n_x}
\end{bmatrix}
\bar{H}_w = \begin{bmatrix}
\big[ \zeros{3}{4} \ \eye{3} \big] & \zeros{3}{n_x} & \cdots & \zeros{3}{n_x} \\
\vdots & \ddots & \ddots & \vdots \\
\zeros{3}{n_x} & \zeros{3}{n_x} & \cdots & \big[ \zeros{3}{4} \ \eye{3} \big]
\end{bmatrix} \quad H_w = \begin{bmatrix}
\bar{H}_w \\ \zeros{N (2n_x+n_u)+1}{3N} 
\end{bmatrix}
\end{gather*}
Without any quadratic constraints, we may now write Problem~\ref{prob:prob2} in standard form as
\begin{problem}
Find the vector $\bm{z}\in\real^{n_z}$ such that
\begin{subequations}\label{eq:prob2}
\begin{align}
\min_{\bm{z}} &\quad \bm{c}^T \bm{z} \tag{\ref{eq:std_cost}}\\
\text{subject to:} &\quad A \bm{z} = b \tag{\ref{eq:std_equality}} \\
&\quad G_{lin} \bm{z} \leq h_{lin} \tag{\ref{eq:std_ineq_lin}}
\end{align}
\end{subequations}
\end{problem}


\end{document}